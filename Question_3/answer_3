Yes, by default, Django signals run in the same database transaction as the caller. This means that if the caller’s database transaction is not committed, the changes made by the signal will not be committed either. Conversely, if the caller's transaction is rolled back, any changes made by the signal’s receiver will also be rolled back.

To demonstrate this, we can use a Django model, the transaction module, and a signal handler. We’ll attempt to update a model in both the caller and the signal handler, and then intentionally roll back the transaction to see if changes made within the signal handler are also rolled back.